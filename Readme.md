- 第1章 始めに
    - 上流品質とは
        - シフトレフト
            - 左側
                - 計画
                - 設計
                - 開発
                - ビルド
            - 右側
                - テスト
                - デプロイ・リリース
            - この左側の上流工程で品質を高めるということ
    
    - 日本のソフトウェアの問題点
        - 設計~開発~デプロイで発生したバグを最終工程のテストで潰そうとすること
    - ソースコードが糞ならバグがクソほど発生する
        - どんなに要求仕様が立派でもコードが糞なら糞。
        - 例えば
            - 200行に一切コメントがないコード
            - if文の中にスイッチ文、その中にcase文
    - 品質コンサルでもコードがバリバリ読める人は少ない
    - 本書の目的
        - Shift Leftすること
        - 楽すること
    - 
        - 
        
- 第2章 上流品質向上のためのテスト
    - すべての工程のバグをシステムテストで解決しようとするとうまくいかない\
        - 開発後半の出荷前にリスクを寄せ集める
        - 結果期日通りに出荷できなくなるリスクもある
            - そうなると協力会社が入ってきてさらに無駄なバグを生むことも。。。
    - 2.1 上流品質活動
        - 品質向上 = システムテストをちゃんとやる
            - これは間違い!!!
        - 上流工程で85%以上のバグを発見できればプロジェクトはうまくいきやすい
            - いくら後半でdバグを見つけても出荷後の不具合がヘルカどうかには限界がある
        - ある種のバグの集合体はシステムテストでは見つからないことが照明されている
            - 統合テストd絵見つかるバグは最大40%
            - システムテストで見つかるバグは55%
            - 大規模ベータで60~75%
        - 上流品質と残バツのリスク
            - 上流でバグを潰さないと
                - 後半い多くのバグが残る
                    - 出荷後に顧客にバグが見つかる
        - コーディング工数に比例してバグが入り込む
            - 最後のレビューやインスペクションをおろそかにして
                - テストを開始し、大部分のエラーが統合テスト・システムテストで見つかる
        - ここで怖いところ
            - プロジェクト後半でバグを潰すには前半で潰すのに比べコストがかかる(効率が悪い)
            - 後半でバグを潰そうとしても潰しきれずに出荷後にバグとして残るリスクがある
        - 一方で、前半からバグを摘発しておけば後半にバグ修正にかかるコストを減らせるし、出荷前に殆どのバグを潰すことができる
            - また万一にシステムテストで不足なバグが発生してもプロジェクト期間中なのでパニクらずに対応できる
        - バグの修正工数
            - 同じバグの修正にかかる工数は開発工程によって最大100倍違ってくる
                - 要求　1
                - アーキテクト　3
                - システムテスト　10
                - 出荷後　100
        - 
    - まとめ
        - 上流テストをしない = 出荷後にバグが発生する
            - これが論理的に証明されている
- 第3章 開発者テストの基本の基本
    - 3.1 開発者がこれだけは知っておくべきテスト手法
        - 単体テストを行っていない組織は設計書を書いていない場合が多い
            - せめてクラス図とシーケンス図だけは書け
                - クラス図
                    - ぶっグクラスを防ぐことができる
                    - リファクタリングの効果が見える
        - 単体テストとして、以下の3つの手法理解・実践すべき
            - 境界値テスト
            - 状態遷移テスト
            - 組み合わせテスト
                - これは限定的に使う手法なので注意深く利用すること
            - 
        - 境界値テスト
            - これさえちゃんとやっとけば80%以上のバグを潰せる
            - 一般に、要求仕様の境界でバグが出やすい
            - 境界はプログラムの魔界
                - 常にバグが潜む
        - 状態遷移テスト
            - 状態をモデル化してテストを行う
                - 状態
                    - と
                - 遷移
                    - に分けて考える
            - 状態マトリックスを使って表で管理する
                - 
        - 
    
- 第4章 コードベースの単体テスト
    - 4.2 コードベースの単体テストとは
        - そもそも単体テスト(unit test)の定義は迷走を繰り返している
        - 単体テストの定義
            - コードに対する確からしさを確認するテスト
                - または
            - 単機能に対するテスト
        - コードベースの単体テスト
            - 関数の網羅率を測定し、
                - ロジックの確からしさを確認するための
                    - ホワイトボックステスト
            - 自動車や医療に関するソフトウェアはISOなどで厳密に定義されている
        - 単体テストでチェックすること
            - プログラム実行中にシステム上異常な振る舞いを行わない
                - null pointer
                - 0による除算など
            - 入力値とそれに対応する期待値を出力すること
            - すべての分岐が正しく処理されること
                - 境界値テスト
    - 4.2 命令網羅 (C0 カバレッジ)
        - 命令網羅テスト
            - または
        - C0網羅
            - とよばれる網羅(テスト網羅性の水準)
        - 実はあまり意味のあるテストとは言えない
            - というか役に立たない
            - 境界値テストがちゃんとできているか測定できないから
        - すべての分岐をテストできない
    - 4.3 分岐網羅(C1 カバレッジ)
        - すべての分岐に対してテストを行う
    - 4.4 よくある単体テストの間違い (コードベースの単体テスト)
        - 網羅さえすればいい!!!
            - そうではない
            - 入力値のパターンを100%網羅しなければならない
                - それに対する期待処理が正しい確認する
        - コードベースの単体テストはほとんどのバグを見つけられる
    - 4.5 知っているようでしらないコードベースの単体テストの書き方
        - なぜ日本人は単体テストが嫌いなのか・・・
        - 一般的なテスト手法　(TDD)
            - テストコードを先に書く
                - その次に処理を書いて、赤→緑→リファクタリングする
            - 
        
    - 4.6 網羅率 (コードベースの単体テストの成否を測定する)
        - 自動車なら100%を目指すべき
        - それ以外のソフトでも80%異常を目指すべき
            - 残りの20%はエラーハンドリングの処理なので単体テストで網羅する必要がない
        - すべてのコードで網羅率を測定する必要はな
            - 全体のうち20%のコードに大半のバグが仕込まれている
            - その部分だけで良い
- 第5章 単体テストの効率化
    - 5.1 コードの複雑度
        - ifとかswitchがたくさんあるとコードが複雑になる
    - 5.2 どこで単体テストをすればよいか? 単体テストやってる暇ありませんという人向け
        - 他の仕事に忙殺されて単体テストができないのは日本の現場の実情
        - 疲弊する理由
            - 重箱の隅を突くようなテストをしんければならない
                - そのバグの修正あ行
            - バグをゼロにしろという無茶振り
            - ハングアップをゼロにしろという(ry
            - バグの再発防止策「しっかりレビューしようね!テストケースを増やそうね!」
                - 改善とは今ある仕事を効率的にし品質をあげること。
                - ただタスクと追加することは改善とは言わない
        - 単体テストのやる箇所を絞る
            - ソフトウェアの2割から8割のバグが生まれる
            - その2割はどこか?
                - 直近に何回変更されたか、その回数が多いファイルからバグが出る
            - また複雑度が高いファイルもバグの元
                - リファクタリングすべき
                    - わからなければとりあえず2つにぶった切れ
        - メリット
            - システムテストのコストをへらすことができる
                - 1/5の単体テストで大きくシステムテストをへらすことできる
                    - Hotspotベースの単体テスト
                    - その後に下流テストで探索的テスト
                        - 下流テストを1/3にする
        - 単体テストに潜む闇
            - 欧米では自動車・インフラの単体テストは必ずやられているが
                - 日本はやっていない場合が多い
            - 
            
- 第6章 機能単位の単体テスト
    - 6.1 開発者がやるべき単機能のテスト
        - 単体テストの明確な解はない
        - コード網羅して単機能のテストをするのは開発者の責務
        - 例　ソート機能の単体テスト
            - テスト手法
                - 単機能境界値
                    - 例えば年齢
                        - 0歳でもエラーがでないか
                        - -1歳をエラー処理できるか
                        - 1000歳でエラーが出るか
                        - 数値以外が入らないか、エラーが出るか
                    - データ件数が
                        - ゼロのとき
                        - 1のとき
                        - とても大きいとき
                - 組み合わせ
                    - どこからバグが出やすいかを考える必要がある
                    - 2つの属性の組み合わせを確実に網羅することが大事
                        - 3つ以上の属性の組み合わせまで考え出すとテストケースは無限に増える
                        - 大抵は2つの組み合わせ条件によるバグで、3つ以上の条件でのバグは少ない
                            - 出たとしてもそれを防ぐための適切なテスト手法はない
                    - 機能単体の機能テストでの組み合わせバグの検出確度は、コードベースの単体テストよりかなり少ない
                - 
    - 6.2 ブラックボックステスト・ホワイトボックステスト
        - どちらをやるべきか？
            - コードベースの単体テスト
            - 機能単位の単体テスト
        - ブラック・ホワイトでバグを見つけられる範囲が異なる
        - 車載ソフト、特にエンジン関係などは、ホワイトボイックステストが必須
            - でもカーナビなら別に・・・
    - 組み合わせテストとシステムテストの怪
        - 組み合わせテストは一番コストがかかる手法
            - でも日本は組み合わせテストに頼り切り
                - そして組み合わせテストが足りないからバグが出たと考えがち
                - なぜ?
                    - 担当者が楽だから
                - 例えば市場でバグが出たとする
                    - 大抵はある入力の組み合わせによって発生する
                    - テストケースにその組み合わせが入っていなかった
                        - 改善策としてテストケースを追加すればいいや、となりがち
        - でも実際そのバグは、else文を書き忘れたとか、単体テストで発見できるものばかり
            - 組み合わせテスト・・・必要ないじゃん・・・となる
- 第7章
    - 7.1 やはり複雑です、そのコード！書けません、単体テスト
        - リファクタリングなしに上流品質が確保できない
        - リファクタリングの流れ
            - ファイルの複雑度が高い場合
                - ファイルをぶった切る
            - それでも複雑度が下がらない場合、
                - 既存の複雑なコードに対して単体テストを書く
            - Mockを書く
            - 網羅率を測定し、網羅率が75%になるまで単体テストを追加する
            - リファクタリングする
                - 意識すること
                    - 複雑度を下げるリファクタリング
                    - 出口を一つにするリファクタリング
                    - MVC分離のリファクタリング
                    - ファイルのコードを短くするリファクタリング
            - 単体テストを実行して結果が同じか確認する
    - 7.2 ファイルのコードのリファクタリング
        - なぜファイルのコードが長くなるか?
            - 責務が適切に分けられていないから
        - 3パターン
            - とりあえずどこにもいいファイルがないからなんとかなくファイルにぶち込んじゃう
            - クローンコードがたくさんある
                - 似た関数をコピペする
                - 関数化をめんどくさがる
            - ビッククラスによるファイルの肥大化
    - 7.3 ビッククラスのリファクタリング
        - ビッククラスがファイルを長くしていることのほうが多い
        - CKメトリックス
            - 一つのメトリックスではなくいくつかのメトリックスの集合体
                - クラス構造が複雑だ
                - 一つのクラスにたくさんのメンバーを突っ込んでるとバグになる
                - とかのメトリクス
                - クラスあたりの平均メソッド数: WMC (Weight Method Per Class)
                    - 一つのクラスあたりメソッドが0-10固まっていて、大きいのはまれ、一番大きい場合106もあった
                    - 筆者の指標
                        - McCabe20以下
                        - WMC20以下
            - WMCが大きいと
                - バグの温床になる
                - コードが長いファイルの80%くらいはこれ
            - 品質の観点から言えばCKメトリックスの値が高いものはリファクタリングすべき
            - WMCサイズを小さくする方法
                - クラス抽出(Martin Fowler)
                    - 大きいクラスをぶった切る
            - ぶった切るメリット
                - Hotspotから外れる部分が出てくる
                    - 単体テスト不要の部分が生まれる
                - 単体テストを書く範囲が小さくなる
                    - つまりテストのコストが小さくなる
            - ビッグクラス
                - 構造化言語以前のカオスな言語と同様に、グローバルな変数の使い方が増え、品質が一気に下る
                - 多数の関数にアクセスされるprivate変数はまったくプライベートではんくグローバル変数となってしまう
                - 
                - 
                - 
                - 
        - 
    - 7.4 複雑度を下げるリファクタリング
        - 複雑度
            - 制御の流れを有効グラフで表現し
                - そのグラフの持つ性質に基づいてプログラムの複雑性を表す方法
        - 複雑度が高い
            - バグを生む悪魔的関数
            - 修正しようとすると別のバグを生む、というか修正すらできない
                - だからこそ早い段階でリファクタリングしておくべき
        - 複雑度が小さい
            - バグのない神がかり的関数
        - 複雑度が高いほど労働時間が増えるというデータも
        - 
    - 7.5 出口は一つ
        - 関数の出口は一つもしくは2つにする
            - 2つの場合は必ず入り口でのパラメータのエラーチェックのみ
        - NG\
            - 関数の真ん中でリターンしない
        - なぜ?
            - 単体テストはin, outのみ振る舞いをチェックする
            - その関数の責務をチェックすべきではない
                - 本当はしたほうがいいが単体テストの複雑性が増す
            - 
                - 
    - 7.6 MVC分離
        - MVC分離
            - MVC以外の品質問題はリカバー可能
            - 逆にMVアーキテクチャが担保されていないプロジェクトを途中から分離させるのはほぼ不可能
        - 
- 第10章 システムテストの自動化
    - 10.1 最悪のシステムテスト
        - テスト自動化で重要なこと
            - メンテナンスコストを最小限に抑える
                - メンテナンスコストが安ければいくらでも自動化テストは再利用できる
        - キャプチャー・リプレイツール
            - 最初のスクリプト作成コストは安いが、
            - メンテナンスコストが最悪
                - もはや手動のほうがやすい
    - 10.2 キーワード駆動形自動テスト
        - 2つの属性を効率的に使う
            - アクションワード
            - データ
        - ポイント
            - アクション(キーワード)とデータを明示的に分けて使うこと
        - たとえbログインUIの場合
            - システムの至るところに出てくるログインスクリプトを
                - 一つのスクリプトにまとめなければならない
                    - キーキャプチャならログインというアクションは何回も発生してしまう→変更のたびに何個もテストの修正が必要
                - これによって修正が1箇所で済むようになる
        
    - 10.3 妄想な自動化
    - 
        
        
- 第11章 探索的テスト
    - 探索的テストとは
        - 個人の自由意志のもとに、個人の責任によりテストを行う
        - 継続的にテスト活動を洗練させる
        - 以下の活動を行う
            - 学習
            - 設計
            - 実行
            - 結果の報告
        - つまりテストケースを書かない
            - テストケース作成・実行は全システムテスト活動の80%を超える
                - それを要求仕様を完璧に理解したスキルあるテスト担当者がやれば、10倍のスピードでテストできるはず
        - viewの部分は探索的テストで、短い時間でやるべき
            - ただし上流の品質保証をしっかりやった場合に限る
                - 基準
                    - コード網羅率80%以上
                        - 分岐網羅
                    - アーキテクチャがMVC分離されている
                    - 各関数のMcCabeが20以下
                    - クラスメンバー関数が10以下
                    - すべての要求仕様がレビューされている
                    - Race Condition(競合)のバグに対して十分対策されている
                        - ある一つのデータに複数のプロセスがアクセスできる状態
                            - タイミングによってはバグになる
        - これによりシステムテストのコストを1/10にできる
        - 
- 第12章 まとめ
    - 単体テストで多くのバグを見つけることが重要
    - システムテストで見つけようとすると最悪の結果を生む
        - 出荷直前に大量のバグが見つかる
        - 出荷後にも大量にバグが見つかる
- 第13章 品質と要求仕様とテストのケース
    - Karlが定義する要求仕様
        - 完全である
        - 正当である
        - 実現可能である
        - 必要である
        - 優先順位が付いている
        - 曖昧さがない
        - テスト可能である
- 第14章 アジャイル開発 vs ウォーターフォール開発
    - 14.1 ウォータフォール開発のプロジェクト管理
        - 開発とテストを2ステップに分割する
            - 開発者
                - フィーチャー(機能)を構築
            - QAチーム
                - テストプランを作成して実施
        - 多くの場合プロジェクトが遅れ、テストがスキップされる
    - 14.2 アジャイル開発の上流品質
        - アジャイル組織で重要な品質要素
            - チーム全体
            - 障壁の解体
            - 測定可能な値やシステム品質の特定
            - システム品質ダッシュボード
            - 品質にスポットしたスプリント
        - 品質を軽んじるアジャイル組織はすべてエセアジャイル
    - 第15章 開発者テストの実サンプル